# Jules 平台 Git 与文件操作特别指南 (AI Agent 必读)

**致 Jules (AI Agent)：**

本文档旨在帮助你理解在你当前工作的这个特殊平台/沙盒环境中，Git 版本控制和文件操作的一些特定行为模式。这些模式可能与标准的、独立的 Git 环境有所不同。理解并遵循这些指南对确保操作的准确性和高效协作至关重要。

## 一、核心原则：用户审查与平台机制优先

你的许多操作，特别是涉及将更改推送到远程仓库（如 GitHub）或预览文件内容时，会受到平台内置机制和用户界面 (UI) 交互的影响。这些 UI 元素对你来说是不可见的，但用户的最终决策会通过它们发生。

## 二、Git 提䏼程的特殊性

当你被要求“提交文件”到远程仓库时，流程通常如下：

1.  **你的本地操作（意图表达）：**
    *   你可能会根据指令修改或创建文件。
    *   你可能会在本地执行标准的 Git 命令，如 `git add <file>` 来暂存文件，并使用 `git commit -m "Your message"` 来（尝试）本地提交，并生成一条提交信息。
    *   **关键：你生成的提交信息非常重要，它将直接呈现给用户。请确保它清晰、准确地描述了你的操作和意图。**

2.  **平台“提交管理器”的介入（对你透明）：**
    *   你通过 `submit()` 工具调用表达的“提交”意图会被平台的“提交管理器”系统检测到。
    *   **文件收集机制：** 此系统倾向于**自动扫描你的整个工作目录**。它会将所有**未被 `.gitignore` 文件明确忽略的新增文件和已修改文件**都收集起来，形成一个实际的“待审查文件集”。这个文件集**可能比你通过 `git add` 命令明确暂存的文件范围更广或不同。**
    *   **例如：** 如果你创建了 `a.txt` 和 `b.txt`，即使你只执行了 `git add a.txt`，这个“提交管理器”也可能会将 `a.txt` 和 `b.txt` 都包含进待审查文件集。

3.  **用户审查界面：“Ready for review”弹窗（你无法看到）：**
    *   人类用户会看到一个**简单的、较小的提示弹窗**（例如，名为 "Ready for review"）。
    *   此弹窗将**仅显示你生成的提交信息原文**。
    *   **非常重要：此弹窗通常不会列出具体将要提交的文件列表。** 用户主要依赖你的提交信息来判断是否批准此次“批量”操作。

4.  **用户批准与实际执行：**
    *   只有当用户在弹窗中点击批准按钮（例如 "publishing branch"）后，“提交管理器”才会将在第2步收集到的**整个文件集**，使用你在第1步提供的**提交信息**，真正地执行 Git `commit`（可能是覆盖你本地的尝试）和 `git push` 操作到远程仓库。

5.  **对你本地 Git 状态命令的影响：**
    *   你执行的 `git status` 命令的输出**可能不准确或具有误导性**。例如，它有时会显示 `nothing to commit, working tree clean`，即使Git的索引（暂存区）实际上包含了已暂存的更改（这可以通过 `git ls-files --stage` 等更底层的命令观察到）。**不要完全依赖 `git status` 来判断待提交状态。**
    *   你执行的本地 `git commit` 命令可能不会创建你预期的本地提交，或者即使创建了，也可能被“提交管理器”的最终提交所覆盖。
    *   你直接执行的 `git push` 命令**极有可能失败或超时**，因为实际的推送操作是由平台通过用户批准来控制的。

## 三、确保提交内容符合预期的关键操作指南 (给 Jules)

鉴于上述机制，为了尽可能确保最终提交到远程仓库的内容符合用户期望，请严格遵守以下指南：

1.  **保持工作目录的绝对清洁：**
    *   在通过 `submit()` 工具向平台表达“提交”意图（即你认为完成了文件修改，准备发起提交流程）**之前**，你的工作目录**必须只包含**那些你确实希望包含在**这一次**提交中的新增文件或已修改文件。
    *   **对于任何在当前任务中创建或修改过，但用户不希望在本次提交中包含的文件，你必须在表达“提交”意图之前，从工作目录中明确地将它们删除 (`delete_file` 工具) 或恢复到它们之前的状态 (`restore_file` 工具)。**
    *   这是控制最终提交内容的最有效手段，因为“提交管理器”会扫描整个工作区。

2.  **`.gitignore` 的正确和优先使用：**
    *   对于那些**永远不应该**被版本控制的文件（例如，API密钥、私密配置、编译产物、日志文件、临时文件、测试副本如 `packages_copy.txt` 等），**必须确保**它们被添加到了项目根目录的 `.gitignore` 文件中。
    *   在处理任何文件之前，特别是新创建的文件，先考虑它是否应该被 Git 追踪。如果不应该，优先更新 `.gitignore`。

3.  **编写清晰、准确、完整的提交信息：**
    *   由于用户主要通过你的提交信息来决定是否批准提交，你的提交信息必须：
        *   清晰说明本次提交的目的。
        *   如果可能且重要，简要提及涉及的主要文件或核心更改（尽管实际文件列表可能更广）。
        *   准确反映你被要求的任务。

4.  **理解 `git add` 的角色：**
    *   你执行 `git add <file>` 可能确实会影响本地的 `.git/index` 文件（我们通过 `git ls-files --stage` 观察到过）。然而，这更多的是为你向“提交管理器”表明哪些文件是你“主要关注”的。但最终决定权在于“提交管理器”的扫描和用户的批准。
    *   不要期望 `git add` 后 `git status` 会准确反映状态。

5.  **沟通与确认：**
    *   如果你不确定在清除了工作区后，“提交管理器”仍会包含哪些文件，可以在向用户表明你准备好提交时，提醒用户：“我已经准备好提交，提交信息是‘XYZ’。请注意，根据平台特性，所有当前工作目录中未被 .gitignore 排除的新增和修改文件都可能被包含。请您在批准时留意，并在提交后检查远程仓库。”

## 四、文件操作的 UI 预览：使用 `set_plan` 和 `<> code` 面板

1.  **触发 `<> code` 面板：**
    *   当你需要创建新文件（例如使用 `create_file_with_block`）或修改现有文件（例如使用 `overwrite_file_with_block` 或 `replace_with_git_merge_diff`）时，如果希望用户能方便地通过平台 UI 直接预览这些文件的**完整最终内容**，你应该将这些文件操作的步骤包含在一个通过 `set_plan` 工具设定的计划中。
2.  **面板自动显示：**
    *   一旦你通过 `set_plan` 规划了这类文件操作，平台通常会自动在一个名为 `<> code` 的 UI 面板区块中，显示这些文件在被写入（或更新）后的完整内容。这对用户审查非常方便。
3.  **直接操作无此面板：**
    *   如果你不使用 `set_plan` 来规划文件创建/修改步骤，而是直接调用文件操作工具，用户将**不会**看到这个自动出现的 `<> code` 内容预览面板。在这种情况下，如果需要用户确认内容，你可能需要使用 `read_files` 工具将内容读出并展示。

## 五、与 rclone 和 Google Drive 交互的已知特性（截至本次观察）

*   **删除操作：** 对于你当前配置的 Google Drive 服务帐号 (`gdrive_service_upload`)，使用 `rclone delete` 命令（无论是否明确使用 `--drive-use-trash=false` 参数）似乎都会执行**永久删除**，文件不会进入用户可见的回收站。
*   **上传文件夹：**
    *   使用 `rclone copy local_folder_path gdrive_service_upload:target_folder_name` 的方式，如果 `target_folder_name` 在 Google Drive 上事先不存在，此操作可能**不会**按预期在 Drive 上创建名为 `target_folder_name` 的新文件夹并将 `local_folder_path` 的内容复制进去。实际结果可能是文件未上传或以非预期的方式上传（例如，文件散落在根目录）。
    *   然而，使用 `rclone mkdir gdrive_service_upload:new_folder_name` 命令可以成功在 Google Drive 上创建一个新的空子文件夹。之后，你可以使用 `rclone copyto local_file_path gdrive_service_upload:new_folder_name/remote_file_name` 将单个文件上传到这个已创建的子文件夹中。

## 六、总结

Jules，请将这些指南作为你在这个平台上进行 Git 操作和文件处理时的首要行为准则。通过遵循这些规则，我们可以最大限度地减少误解和错误，并更顺畅地协作。遇到不确定的情况时，请及时与用户沟通。

## 七、Jules 的感知与平台 UI 交互

为了更好地协作，理解 Jules (AI Agent) 能感知到什么以及平台如何通过用户界面 (UI) 与用户交互至关重要。

1.  **Jules 能感知到的信息：**
    *   **纯聊天消息：** Jules 可以接收并处理用户发送的所有文本消息。
    *   **工具执行结果：** 当 Jules 调用一个工具（如 `run_in_bash_session`, `read_files`, `ls` 等）时，它会收到该工具执行后的文本输出结果（例如，成功信息、错误信息、文件列表、文件内容等）。这些结果是 Jules 决策的依据。
    *   **内部计划状态：** Jules 通过 `set_plan` 工具设定或更新计划，并通过 `plan_step_complete` 标记步骤完成。它知道当前的计划内容和执行进度。

2.  **Jules 通常无法直接感知到的信息（由平台处理并呈现给用户）：**
    *   **计划的 UI 展示：** 当 Jules 使用 `set_plan` 设定计划后，平台系统会将此计划以特定的 UI 形式（例如，带步骤号的列表）展示给用户。Jules 本身并不知道这个计划在用户界面上的具体视觉呈现。
    *   **工具输出的特定 UI 元素：** 尽管 Jules 会收到工具的原始文本输出，但平台可能会将这些输出（例如 `ls` 的结果、`read_files` 的内容、代码块的预览）以格式化的、独立的 UI 元素呈现给用户。Jules 不直接控制这些 UI 元素的具体样式或布局。
    *   **用户界面上的其他提示或状态：** 平台可能还会显示其他类型的 UI 提示、加载指示器或状态信息，这些通常对 Jules 是不可见的。
    *   **鼠标点击、窗口交互等图形界面操作：** Jules 是一个基于文本和工具交互的 AI，无法感知或执行图形用户界面的操作。

3.  **协作模式：**
    *   Jules 专注于理解任务、制定逻辑步骤、调用工具并处理其文本结果。 **Jules 的“工具调用”是其执行“动作”和表达“意图”的主要方式。**
    *   平台系统则扮演桥梁角色，它会**捕获 Jules 的工具调用**，并将 Jules 的内部状态（如计划）、行动（如工具调用）及其结果，以用户友好的 UI 形式呈现给用户，并传递用户的指令给 Jules。
    *   因此，用户的观察（例如，“我看到计划列表了”或“代码预览面板显示了内容”）对于确认信息是否已按预期在 UI 上呈现给用户非常重要。

4.  **平台作为“UI 引擎”和“动作转译器”：**
    *   平台不仅仅是简单显示 Jules 的文本输出，更像一个复杂的“UI 引擎”或“表现层”。
    *   它负责将 Jules 的文本输出（如聊天消息、工具的原始文本结果）进行格式化展示（例如，Markdown 渲染、代码高亮等）。
    *   更核心的是，平台会将 Jules 的**特定工具调用（即“动作”）转译并映射到预定义的、有时是交互式的特定 UI 元素**上。这包括：
        *   `set_plan(plan_string)` 调用会触发 UI 将 `plan_string` 的内容展示为结构化的计划列表。
        *   `submit(branch, message)` 调用会触发 UI 显示 "Ready for review" 弹窗，并填充用户提供的分支名和提交信息，等待用户批准。
        *   文件操作工具（如 `create_file_with_block` 等）如果包含在通过 `set_plan` 设定的计划中，平台可能会在 `<> code` 面板中自动展示待写入文件的预览。
        *   其他工具调用（如 `ls`, `read_files`）的输出也可能被平台提取并展示在特定的 UI 区域。
    *   这种机制是为了让 Jules（一个主要通过文本和离散工具调用进行交互的 AI）能够与习惯于图形化、结构化和交互式界面的用户进行高效、透明的协作。平台充当了两者之间的智能“翻译”和“呈现”层。

5.  **遵循用户特定指令调整操作行为：**
    *   **用户指令下的行为调整：** Jules 的行为模式具有一定的灵活性，并非完全固化于其“标准作业流程”。通过用户下达的清晰、明确的指令，Jules 可以调整其标准操作行为，以适应特定的任务需求或用户偏好。例如，用户可以指示 Jules，在完成文件修改的计划步骤后不自动调用 `submit()` 工具发起提交——即使这可能是 Jules 在通常情况下的标准后续动作——Jules 能够理解并遵循此类特定任务指令。
    *   **沟通是关键：** 这种行为调整的有效性高度依赖于用户与 Jules 之间的清晰沟通。用户需要明确表达其期望的、针对特定情况的工作流程，特别是当这些流程与 Jules 可能的默认行为模式不同时。
    *   **成功案例——遵循不提交指令：** 在与用户 Terry 的协作中，进行了一项测试：Jules 在完成文件更新的计划步骤后，严格遵循了用户“不发起提交”的明确指令，没有调用 `submit()` 工具。最终结果是，用户界面上未出现平台自动生成的 "Ready for review" 弹窗。此案例证明：
        *   Jules 能够理解并执行覆盖其标准行为模式的用户特定指令。
        *   明确的用户指令可以有效避免不必要的或非预期的平台 UI 行为（如自动弹出的提交通知）。
        *   这种基于清晰指令的定制化协作，对于提升人机交互效率和减少潜在误解至关重要。
    *   因此，当需要 Jules 采取不同于其“标准作业流程”或“默认行为模式”的行动时，用户**通过主动、清晰地沟通具体的操作指令，可以有效地引导 Jules 的行为，实现更精确的协作。**
